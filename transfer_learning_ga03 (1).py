# -*- coding: utf-8 -*-
"""Transfer_learning_GA03

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xaQNBVe_nP4cvgNTSaWPA9livydKeS5b
"""

import os
import pandas as pd

# Caminho para o dataset
ESC_50_AUDIO_PATH = "/content/gdrive/My Drive/ESC-50/Audio"
ESC_50_METADATA_PATH = "/content/gdrive/My Drive/ESC-50/meta/esc50.csv"

#Trocar o caminho que está para aceder aos audios e os metadados para o caminho próprio, no meu caso tenho o caminho a partir da drive

# Carregar metadados
esc50_metadata_df = pd.read_csv(ESC_50_METADATA_PATH)

# Visualizar as primeiras linhas
print(esc50_metadata_df.head())

import tensorflow_hub as hub

# Carregar o modelo YAMNet pré-treinado
yamnet_model = hub.load('https://tfhub.dev/google/yamnet/1')

import librosa
import numpy as np

def extract_yamnet_features(audio_path):
    # Carregar o áudio
    waveform, sample_rate = librosa.load(audio_path, sr=16000)  # YAMNet requer 16 kHz

    # Extrair embeddings com YAMNet
    embeddings, _, _ = yamnet_model(waveform)

    # Tirar a média dos embeddings ao longo do tempo
    return np.mean(embeddings.numpy(), axis=0)

esc50_metadata_df['file_path'] = esc50_metadata_df.apply(
    lambda row: os.path.join(ESC_50_AUDIO_PATH, row['filename']), axis=1
)

from tqdm import tqdm

features = []
labels = []

for index, row in tqdm(esc50_metadata_df.iterrows(), total=len(esc50_metadata_df)):
    file_path = row['file_path']
    target = row['target']  # Classe do som

    # Extrair features com YAMNet
    yamnet_features = extract_yamnet_features(file_path) # extrai os embeddings dos audios do dataset ESC-50

    features.append(yamnet_features) # coloca os embeddings dos audios em features
    labels.append(target) # coloca  os rotulos dos audios em labels

features_df = pd.DataFrame(features)
features_df['label'] = labels

#Nao correr esta celula se for para correr novo dataset de testing

from sklearn.model_selection import train_test_split

X = features_df.iloc[:, :-1].values  # Features extraídas do aúdio (são os embeddings gerados pelo yamnet. Cada linha de X é um vetor de 1024 )
y = features_df['label'].values     # Labels(rótulos associados a cada som no dataset ESC-50)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
#Modelo é treinado em 80% dos dados-> (x_train e y_train) e avaliado nos outros 20% ->(X_test e Y_test)

#Correr esta celula e não a de cima se para testar novo dataset de testing
from sklearn.model_selection import train_test_split

X_test = features_df.iloc[:, :-1].values  # Features extraídas do audio do novo dataset (são os embeddings gerados pelo yamnet. Cada linha de X é um vetor de 1024 )
y_test = features_df['label'].values     # Labels(rótulos associados a cada som no dataset de testing)

#Não treinar o modelo com o novo dataset, apenas avaliar a performance.Assim usamos o aprendizado do modelo usando o ESC-50
#Logo, comentar ou não correr a célula seguinte ao avaliar o modelo

from sklearn.ensemble import RandomForestClassifier

classifier = RandomForestClassifier(n_estimators=100, random_state=42) #cria uma floresta de 100 arvores de decisão e com mesma semente
classifier.fit(X_train, y_train) # treina o random florest com os dados de treino x_train e os embeddings das classes associadas
#Durante o treinamento cada árvore é ajustada para aprender padrões e regras que associem embeddings com as classes dos sons
#Cria árvores usando amostras aleatórias de X_train e subconjuntos de características para criar diversidade nas árvores

from sklearn.metrics import accuracy_score, classification_report

y_pred = classifier.predict(X_test) #usa o modelo treinado para prever os rotulos das amostras em X_test que contem os embeddings
#y_pred são as classes previstas pelo modelo para o conjunto de embeddings dos dados de testes fornecidos
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred))

from sklearn.model_selection import cross_val_score
from sklearn.ensemble import RandomForestClassifier

clf = RandomForestClassifier(random_state=42)
scores = cross_val_score(clf, X, y, cv=5)
print("Scores da validação cruzada:", scores)

#pois algumas classes podem ser descaracterizadas